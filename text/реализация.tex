\section{Программная реализация}

После изучения алгоритма Тарского была начата работа по реализации этого алгоритма для формул без параметров.

\begin{definition}
    Формула $\mathcal{A}$ называется \textbf{формулой без параметров}, если для любой ее подформулы вида $(Qx)\mathcal{B}$, формула $\mathcal{B}$ свободна от вхождений кванторов и от переменных, возможно, за исключением переменной $x$.
\end{definition}

\subsection{Постановка задач}

Для поэтапного создания программы были сформулированы и решены следующие задачи:
\begin{itemize}
    \item Разработать архитектуру приложения, реализовать функции отдельных его блоков в виде интерфейсов;
    \item Реализовать систему, решающую задачу получения данных извне, например, из файла или консольного приложения;
    \item Реализовать систему, решающую задачу преобразования данных в формат, в котором формула будет выводиться экран или сохраняться в файл;
    \item Реализовать систему лексического и синтаксического анализов формул языка элементарной алгебры;
    \item Реализовать систему эквивалентных преобразований формул, реализовать алгоритм Тарского как одно из таких преобразований;
    \item Реализовать консольное приложение, которое применяет алгоритм Тарского к введенной формуле и выводит в консоль результат его работы;
    \item Покрыть основные модули программы модульными и интеграционными тестами.
\end{itemize}

\subsection{Инструменты разработки}

Для реализации алгоритма были выбраны язык C\# версии 9.0 и платформа .NET Core 5 \cite{TroelsonNet}. Такой выбор обусловлен рядом причин:
\begin{itemize}
    \item Язык C\#~--- это объектно-ориентированный язык программирования, а данная парадигма программирования позволяет абстрактно описывать объекты, в том числе и математические объекты; 
    \item .NET Core и .NET Standard~--- это современные, развивающиеся и востребованные кроссплатформенные технологии с открытым исходным кодом;
    \item Развитые и удобные средства параллельного программирования языка.
\end{itemize}

Написание программы осуществлялось в среде разработки Rider версии 2020.3. Доступ к программе был получен по студенческой лицензии (рис. \ref{fig:ide}).

\begin{figure}[ht]
    \begin{center}
        \begin{minipage}[ht]{0.8\linewidth}
            \center{\includegraphics[width=0.99\linewidth]{О IDE.PNG}}
        \end{minipage} 
    \end{center}
    \caption{Информация о среде разработки.}  
    \label{fig:ide}
\end{figure}

\subsection{Архитектура приложения}

В результате проделанной работы по проектированию приложения, исходя из предыдущего опыта создания программ, преобразующих логические формулы \cite{Gibadulin1}, было решено разделить программу на следующие слабосвязанные системы:

\begin{itemize}
    \item Система ввода~--- InputSubsystem. 
    
    Система выполняет функцию получения данных извне, например, из файла или консольного приложения;

    \item Система вывода~--- OutputSubsystem.

    Эта система решает задачу преобразования внутреннего формата представления формулы в человекочитаемый формат;

    \item Система парсинга~--- ParserSubsystem.
    
    Данный модуль методами лексического и синтаксического анализов из символьного представления формулы строит объект-формулу, с которой будут работать преобразователи. Также в этом модуле определяется реализация формулы как объекта; 

    \item Система эквивалентных преобразований~--- ProcessorsSubsystem.
    
    Данная система определяет реализации процессоров, то есть эквивалентных преобразований формул. В том числе здесь располагается реализация алгоритма Тарского;

    \item Консольное приложение для демонстрации результатов работы алгоритма Тарского.
    
    И наконец в этой части программы создано консольное приложение для демонстрации работы программы и алгоритма Тарского.

\end{itemize}
Взаимодействие между система происходит следующим образом:
\begin{itemize}
    \item Пользователь вводит с клавиатуры формулу в окне консольного приложения;
    \item Система ввода считывает эту формулу и передает в систему парсинга в виде последовательности символов;
    \item Система парсинга по последовательности символов строит объект средствами лексического или синтаксического анализов, представляющий собой формулу языка элементарной алгебры, и который умеют обрабатывать преобразователи;
    \item Система эквивалентных преобразований применяет процессоры, в том числе, алгоритм Тарского, для построения эквивалентной формулы. Полученная эквивалентная формула передаётся в системы вывода;
    \item Система вывода преобразует формулу в строковый вид, в котором она выводится в окно консольного приложения пользователю.
\end{itemize}
Далее рассмотрим каждую систему и её реализацию подробнее. 

\subsection{Система ввода}

Система ввода должна решать получения данных извне, например, из файла или консольного приложения, и передачи эти данных в виде последовательности символов в систему парсинга.

\subsubsection{Интерфейс}

Система ввода представлена интерфейсом IInput<T> (листинг \ref{IInput}). Интерфейс является обобщенным и ковариантным. Тип T должен реализовывать интерфейс ISymbol, который не содержит ни одного метода и ни одного свойства. Интерфейс содержит один метод MoveNext, который пытается перейти к следующему символу во входных данных и возвращает сигнал об успешности этого действия, то есть этот метод аналогичен одноименному методу интерфейса IEnumerator. Также интерфейс определяет два доступных только для чтения свойства: Current и IsOver. Первое возвращает текущий просматриваемый элемент входной последовательности. Второй истинно, если чтение входной последовательности завершено, иначе ложно.

Таким образом, интерфейс позволяет последовательно получать символы введенные пользователем в виде объектов типа T.

\lstinputlisting[label={IInput},caption={Интерфейс IInput<T>},captionpos=b]{../source/InputSubsystem/IInput.cs}

\subsubsection{Реализация}

Прежде чем перейти к реализации интерфейса IInput, предложим реализацию интерфейса ISymbol~--- класс Symbol (листинг \ref{Symbol}). Он предоставляет информацию о непосредственно символе и о его порядковом номере во входных данных.

\lstinputlisting[linerange={1-9,12-14},label={Symbol},caption={Класс Symbol},captionpos=b]{../source/InputSubsystem/Symbol.cs}

Интерфейс реализован классом TextReaderInput (листинг \ref{TextReaderInput}). Можно сказать, что класс является оберткой над классом System.IO.TextReaderInput. Во-первых, конструктор требует всего один аргумент типа TextReaderInput. В конструкторе инициализируются приватные поля класса и свойства интерфейса. Во-вторых, метод MoveNext при каждом вызове пытается прочитать очередной символ из \_textReader. Если прочитать символ не получилось или прочитанный символ является символом перевода конца строки, то чтение прекращается. Иначе в Current помещается новый объекта типа Symbol, полученный из прочитанного символа и текущего числа символов, счетчик символов \_symbolNumber увеличивается на один.

\lstinputlisting[linerange={4-12,17-20,31-37},label={TextReaderInput},caption={Класс TextReaderInput},captionpos=b]{../source/InputSubsystem/TextReaderInput.cs}

Непосредственно для ввода данных с консоли реализован класс ConsoleInput, который является классом наследником класса TextReaderInput (листинг \ref{ConsoleInput}).

\lstinputlisting[linerange={3-11},label={ConsoleInput},caption={Класс ConsoleInput},captionpos=b]{../source/InputSubsystem/ConsoleInput.cs}

А для чтения данных из файла~--- класс FileInput  (листинг \ref{FileInput}).

\lstinputlisting[linerange={3-16},label={FileInput},caption={Класс FileInput},captionpos=b]{../source/InputSubsystem/FileInput.cs}

\subsection{Система парсинга}

Система парсинга решает задачу лексического и синтаксического анализов формулы языка элементарной алгебры, а также определяет внутреннее представление формулы в виде объекта.


\subsubsection{Интерфейс}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


\subsubsection{Реализация}




\subsection{Система вывода}

Система вывода решает задачу преобразования данных в формат, в котором формула будет выводиться экран или сохраняться в файл.


\subsubsection{Интерфейс}

преобразование формул 



\subsubsection{Реализация}


\subsection{Система эквивалентных преобразований}

\subsubsection{Интерфейс}

\subsubsection{Реализация}
На самом деле тут будет много подпунктов для каждого куска алгоритма

\subsection{Тестирование}
Тут давай пару слов про то, что вот эти и эти блоки покрыл юнит тестами, а эти покрыл интеграционными

\subsection{Примеры результатов работы программы}
Тут кучу скриншотиков успешной работы, на обраблтку ошибок пофигу

\subsection{О возможных приложениях}
Тут хочу набулшитить про coq, про то что эту систему можно переиспользовать и дополнять, про то, что мкак применить в бзепансоти: задача безопаности -> математическая модель -> формальный язык -> получили тоже самое, чем я занимаюсь -> доказать механичеким путём безопаностть системы
